# JAVA项目教程 2022年7月21 日
   `JAVA` 
   1.JAVA语言的特点
    1.简单易学
    2.面向对象(封装、继承、多态);
    3.平台无关性(Java虚拟机实现平台无关性)
    4.可靠性
    5.安全性
    6.支持多线程(C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能能来进行多线程程序设计，而Java语言却提供了多线程支持);
    7.支持网络编程并且很方便(Java语言诞生本身就是为了简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便)
    8.编译与解释并存

   























   

   

   

- [x] this
- [x]
  *笔记
  containsKey:判定是否包含指定键名
  <cd> listcd  
  (CD cd)
  list.add

Overide
**_方法覆盖重写的注意事项:_**
* 1 必须保证父子类之间方法的名称相同，参数列表也相同
* @override 写在方法前面用来检测是不是有效的正确覆盖重写
* 这个注释就算不写，只要满足要求也是正确的方法覆盖重写
*
* 2.子类方法的返回值必须【小于等于】父类方法的返回值范围
* 扩展java.lang.object类是所有类的公共最高父类，java.lang.String就是object的子类
*3 .子类方法的权限必须大于等于父类方法的权限修饰符
* 扩展public>protected> default >private
* default是留空


**先有父类的内容再有子类的内容（super）**
  * 1.子类构造方法当中有一个默认隐含的 super() 调用，所以一定是先调用的父类构造，后执行子类构造
  * 2.可以通过super关键字来子类构造调用父类重载
  * 3.super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造
  * 4.子类必须调用父类构造方法，不写则赠送super(),写了则用写的指定super调用,“super只能用一个，还必须是第一个”。
      super关键字的用法有3钟；
  * 1.在子类的成员方法钟，访问父类的成员变量。
  * 2.在子类的成员方法钟，访问父类的成员方法
  * 3.在子类的构造方法中，访问父类的构造方法
  * super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三中；
 *
 * 1.在本类的成员方法中，访问本类的成员变量；
 * 2.在本类的成员方法中，访问本类的另一个成员方法；
 * 3.在本类的构造方法中，访问本类的另一个构造方法；
 * 在第三种用法中要注意；
 *   A. this(..)调用也必须是构造方法的第一个语句，唯一个。
 *   B.super和this两种构造调用不能同时使用。

 		*JAVA的语言是单继承的，一个类的直接父类只能有唯一一个
 * JAVA语言可以多级继承
 * 一个子类的直接父类是唯一的，但一个父类可以拥有很多个子类
 * super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三中；
 *
 * 1.在本类的成员方法中，访问本类的成员变量；
 * 2.在本类的成员方法中，访问本类的另一个成员方法；
 * 3.在本类的构造方法中，访问本类的另一个构造方法；
  * 在第三种用法中要注意；
 *   A. this(..)调用也必须是构造方法的第一个语句，唯一个。
 *   B.super和this两种构造调用不能同时使用。


        **异常**

  * 访问了数组中的3索引，而数组是没有3索引的，者时候jvm就会检测出程序会出现异常
      * JVM会做两件事情
      * 
               1.JVM会根据异常产生的原因创建一个异常对象，这个异常对象包含了异常产生的(内容,位置，原因)
                         new ArrayIndexOutOfBoundsException("3");
                 2.在getElement方法中，没有异常的处理逻辑(try catch),那么JAVM就会把异常对象抛出给方法的调用者
                 Main来处理这个异常
                 
                 getElement方法把异常对象抛出给main方法
      
      
                 main方法接收到了这个异常对象,main方法也没有异常的处理逻辑
                 继续把对象抛出给main方法的调用者JVM处理
           
                 Main方法把异常对象抛出给JVM
      
       
      
      
                 JVM接收到了这个异常对象，做了两件事情
                     1.把异常对象(内容，原因，位置)以红色的字体打印在控制台上
                     2.JVM会终止当前正在执行的java程序-->中断处理
      
      
      
      throws关键字:异常处理的第一种方式,交给别人处理
         作用:
             当方法内部抛出异常对象的时候,那么我们就必须处理这个异常对象
             可以使用throws关键字处理异常对象,会把异常对象声明抛出给方法的调用者处理(自己不处理,给别人处理),最终交给JVM处理-->中断处理
         使用格式:在方法声明时使用
             修饰符 返回值类型 方法名(参数列表) throws AAAExcepetion,BBBException....{
                 throw new AAAException("产生原因");
                 throw new BBBException("产生原因");
                 ...
      
             }
             注意
                 1.throws关键字必须写在方法声明处
                 2.throws关键字后边声明的异常必须是Exception或者是Exception的子类
                 3.方法内部如果抛出了多个异常对象,那么throws后面必须也声明多个异常
                     如果抛出的多个异常有父子类关系,南无直接声明父类异常即可
                 4.调用一个声明抛出异常的方法,我们就必须处理声明的异常
                     要么继续使用throws声明抛出,交给方法的调用者处理,最终交给JVM
                     要么try...catch自己处理异常
      
      
      ​               
      ​           

  <Html>                   

*   创建多线程程序的第二种方式:实现Runnable接口

*   java.lang.Runnable
*           Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run的无参数方法.
*   java.lang.Thread类的构造方法
*       Thread(Runnable target)分配新的Threed对象.
*       Thread(Runnable target,String name)分配新的 Thread对象
*
*   实现步骤:
*       1.创建一个Runnable接口的实现类
*       2.在实现类中重写Runnable接口的run方法，设置线程任务
*       3创建一个Runable接口的实现类对象
*       4.创建Thread类对象,构造方法中国传递Runnabel接口的实现类对象
*
*   实现Runnable接口创建多线程程序的好处:
*       1.避免了单继承的局限性
*           一个类只能继承一个类,类继承了Thread类就不能继承其他的类
*           实现了Runnable接口,还可以继承其他类,实现其他的接口
*       2.增强了程序的扩展性,降低了程序的耦合性(解耦)
*           实现Runnable接口的方法,把设置线程任务和开启线程进行了分离(解耦)
*           实现类中,重写了run方法:用来设置线程任务
*           创建Thread类对象,调用start方法；用来开启新线程




    等待与唤醒机制:线程之间的通信
    重点:有效的利用资源(生产一个包子eat一个包子, age eat一个包子)
    通信；对包子的状态进行判断
              没有包子-->吃货线程唤醒包子铺线程-->吃货线程等待-->包子铺线程做包子-->做好包子-->修改包子的状态未有
              有包子-->包子铺线程唤醒吃货线程-->包子铺线程等待-->吃货包子-->吃完包子-->修改包子的状态为没有
              没有包子-->吃货线程唤醒包子铺线程-->吃货线程等待-->包子铺线程做包子-->做好包子-->修改包子的状态未有


​              
        注意:哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行,因为它当初中断的地方是在同步块内，而此刻
        它已经不持有锁，所以它需要再次尝试去获取锁(很可能面临其它线程的竞争)成功后才能在当初调用wait方法之后的地方恢复执行
        
      总结如下:  
        如果能获取锁,线程就从WAITING状态变成RUNNABLE状态
        否则,从wait set出来,又进入entry set,线程就从WAITING状态又变成BLOCKED状态


​        
​        
​        
        线程池的概念和原理
        当程序第一次启动的时候,创建多个线程,保存到一个集合中
        当我们想要使用线程的时候,就可以从集合中取出来线程使用
        Thread t=list.remove(0); 返回的是被移除的元素,(线程只能被一个任务使用)
        Thread t = linked.removeFist();
        当我们使用完毕线程,需要把线程归还给线程池
        list.add(t)
        linked.addLast(t);
        
        JDK1.5之后内置了线程池,我们可以直接使用

<HTML>